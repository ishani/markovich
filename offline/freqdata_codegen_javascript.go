package main

import (
	"bytes"
	"fmt"
	"os"
	"sort"
)

// ------------------------------------------------------------------------------------------------
func codegenJsStart(path string, namespace string) *codeGenUtil {

	buf := new(bytes.Buffer)
	buf.Grow(1024 * 8)

	buf.WriteString("// generated by markovich:tablegen\n// ishani.org\n\n")

	return &codeGenUtil{buf, path, namespace}
}

// ------------------------------------------------------------------------------------------------
func (cg *codeGenUtil) finishJs() {

	if err := os.WriteFile(cg.path, cg.buf.Bytes(), 0644); err != nil {
		panic(err)
	}
}

// ------------------------------------------------------------------------------------------------

func (cg *codeGenUtil) emitJsRoots(fqd *freqdata) {

	var buildBuffer bytes.Buffer

	numRoots := 0
	breakPt := 0
	for _, k := range fqd.trigramsSorted {

		numBranches := len(fqd.trigrams[k])
		if numBranches > 2 {

			if breakPt == 0 {
				buildBuffer.WriteString("    \"")
			}
			breakPt++

			buildBuffer.WriteString(k)
			numRoots++

			if breakPt == 40 {
				buildBuffer.WriteString("\" +\n")
				breakPt = 0
			}
		}
	}
	if breakPt != 0 {
		buildBuffer.WriteString("\"")
	}
	buildBuffer.WriteString(";\n\n")

	cg.buf.WriteString(fmt.Sprintf("\n\nconst E_TRIGRAM_ROOTS = %d;\n", numRoots))
	cg.buf.WriteString("const G_TRIGRAM_ROOTS = \n")
	cg.buf.WriteString(buildBuffer.String())

	cg.buf.WriteString("function BeginGeneration(input_user_random_u32) {\n")
	cg.buf.WriteString("	const chosen_index = input_user_random_u32 % E_TRIGRAM_ROOTS;\n")
	cg.buf.WriteString("	const startIndex = chosen_index * 3;\n")
	cg.buf.WriteString("	return TrigramAssembler.fromRootChars( G_TRIGRAM_ROOTS.substring(startIndex, startIndex + 3) );\n")
	cg.buf.WriteString("}\n")
}

// ------------------------------------------------------------------------------------------------

func (cg *codeGenUtil) emitJsSelector(fqd *freqdata) {

	cg.buf.WriteString("function SelectNextLetter(\n")
	cg.buf.WriteString("    trigram_u32,\n")
	cg.buf.WriteString("    input_weight,\n")
	cg.buf.WriteString("    input_seed,\n")
	cg.buf.WriteString("    decision_fn )\n")
	cg.buf.WriteString("{\n")
	cg.buf.WriteString("    const initial_letter_code = trigram_u32 & 0xff;\n")
	cg.buf.WriteString("    const initial_letter = String.fromCharCode(initial_letter_code);\n\n")
	cg.buf.WriteString("    switch (initial_letter)\n")
	cg.buf.WriteString("    {\n")

	var lastRune byte
	for _, k := range fqd.trigramsSorted {

		// emit new top-level case statements if we change to a new inital-letter
		if lastRune != k[0] {
			if lastRune != 0 {
				cg.emitSelectorCaseClose(lastRune)
			}
			lastRune = k[0]
			cg.emitSelectorCaseOpen(lastRune)
		}

		curTri := fqd.trigrams[k]
		newBranches := len(curTri)

		// unpack the map of byte->weight to an array that we can then sort
		var sortedTri []sortableBranch
		for b, f := range curTri {
			sortedTri = append(sortedTri, sortableBranch{b, f})
		}

		// .. do so, by weight
		sort.Slice(sortedTri, func(i, j int) bool {
			return sortedTri[i].weight > sortedTri[j].weight
		})

		//
		cg.buf.WriteString(fmt.Sprintf("            // %s\n", k))
		cg.buf.WriteString(fmt.Sprintf("            case 0x00%02x%02x%02x:\n", k[2], k[1], k[0]))
		cg.buf.WriteString("            {\n")

		// only one branch? just return the letter
		if newBranches == 1 {

			for _, st := range sortedTri {
				cg.buf.WriteString(fmt.Sprintf("                return '%s';\n", quoteCharacter(st.letter)))
			}

		} else {
			// multiple branches; plug out the list of characters and weights, then call the decision fn

			cg.buf.WriteString("                const  data_chars   = \"")
			for _, st := range sortedTri {
				cg.buf.WriteString(quoteCharacter(st.letter))
			}
			cg.buf.WriteString("\";\n")

			cg.buf.WriteString("                const data_weights = [\n")
			for _, st := range sortedTri {
				fxp := uint16(Round(float64(st.weight) * 0x00010000))
				cg.buf.WriteString(fmt.Sprintf("                    0x%04x, // %f \n", fxp, st.weight))
			}
			cg.buf.WriteString("                ];\n")

			cg.buf.WriteString("                return decision_fn( data_chars, data_weights, data_chars.length, input_weight, input_seed );\n")
		}

		cg.buf.WriteString("            }\n")
		cg.buf.WriteString("            break;\n\n")
	}
	if lastRune != 0 {
		cg.emitSelectorCaseClose(lastRune)
	}

	cg.buf.WriteString("    }\n")
	cg.buf.WriteString("    return 0;\n")
	cg.buf.WriteString("} // SelectNextLetter()\n")
}

// ------------------------------------------------------------------------------------------------
func codegenJsProcessor(fqd *freqdata, path string, namespace string) {

	outputfile := fmt.Sprintf("%smk-selector-%s.js", path, namespace)

	hdr := codegenJsStart(outputfile, namespace)
	hdr.emitJsSelector(fqd)
	hdr.emitJsRoots(fqd)
	hdr.finishJs()
}
