package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"sort"
)

type headergen struct {
	buf       *bytes.Buffer
	path      string
	namespace string
}

// ------------------------------------------------------------------------------------------------
func codegenStartHeader(path string, namespace string) *headergen {

	buf := new(bytes.Buffer)
	buf.Grow(1024 * 8)

	buf.WriteString("// generated by markovich:tablegen\n// ishani.org 2021\n\n")
	buf.WriteString("namespace mk {\n")
	buf.WriteString(fmt.Sprintf("namespace %s {\n\n", namespace))

	return &headergen{buf, path, namespace}
}

// ------------------------------------------------------------------------------------------------
// the trigram 'roots' is just a big list of all the trigrams in sorted order; we use this to start
// generating a new name, seeding the process with a set of letters that are guaranteed to have
// some branches to walk along
//
func (hd *headergen) emitRoots(fqd *freqdata) {

	var buildBuffer bytes.Buffer

	numRoots := 0
	breakPt := 0
	for _, k := range fqd.trigramsSorted {

		numBranches := len(fqd.trigrams[k])
		if numBranches > 2 {

			if breakPt == 0 {
				buildBuffer.WriteString("    \"")
			}
			breakPt++

			buildBuffer.WriteString(k)
			numRoots++

			if breakPt == 40 {
				buildBuffer.WriteString("\"\n")
				breakPt = 0
			}
		}
	}
	if breakPt != 0 {
		buildBuffer.WriteString("\"")
	}
	buildBuffer.WriteString(";\n\n")

	hd.buf.WriteString(fmt.Sprintf("enum { eTrigramRoots = %d };\n\n", numRoots))
	hd.buf.WriteString("static const char g_trigramRoots[ (eTrigramRoots * 3) + 1 ] = \n")
	hd.buf.WriteString(buildBuffer.String())

	hd.buf.WriteString("#include \"inline/common-roots.inl\"\n")
}

// ------------------------------------------------------------------------------------------------
//
//
func quoteCharacter(character byte) string {
	if character == '\'' {
		return "\\'"
	}
	return fmt.Sprintf("%c", character)
}
func (hd *headergen) emitSelectorCaseOpen(character byte) {
	hd.buf.WriteString("        // -- -- -- -- -- -- -- -- -- -- -- --\n")
	hd.buf.WriteString(fmt.Sprintf("        case '%s':\n", quoteCharacter(character)))
	hd.buf.WriteString("        {\n")
	hd.buf.WriteString("            switch ( trigram_u32 )\n")
	hd.buf.WriteString("            {\n")
}

func (hd *headergen) emitSelectorCaseClose(character byte) {
	hd.buf.WriteString("            } // switch _u32\n")
	hd.buf.WriteString(fmt.Sprintf("        } // %c\n", character))
	hd.buf.WriteString("        break;\n\n")
}

type sortableBranch struct {
	letter byte
	weight float32
}

func (hd *headergen) emitSelector(fqd *freqdata) {

	hd.buf.WriteString("MKV_DISABLE_OPT\n")
	hd.buf.WriteString("static char SelectNextLetter(\n")
	hd.buf.WriteString("    const uint32_t          trigram_u32,\n")
	hd.buf.WriteString("    const float             input_weight,\n")
	hd.buf.WriteString("    const uint32_t          input_seed,\n")
	hd.buf.WriteString("    BranchDecisionFunction  decision_fn )\n")
	hd.buf.WriteString("{\n")
	hd.buf.WriteString("    const char initial_letter = (char)( trigram_u32 & 0xff );\n")
	hd.buf.WriteString("    switch (initial_letter)\n")
	hd.buf.WriteString("    {\n")

	var lastRune byte
	for _, k := range fqd.trigramsSorted {

		// emit new top-level case statements if we change to a new inital-letter
		if lastRune != k[0] {
			if lastRune != 0 {
				hd.emitSelectorCaseClose(lastRune)
			}
			lastRune = k[0]
			hd.emitSelectorCaseOpen(lastRune)
		}

		curTri := fqd.trigrams[k]
		newBranches := len(curTri)

		// unpack the map of byte->weight to an array that we can then sort
		var sortedTri []sortableBranch
		for b, f := range curTri {
			sortedTri = append(sortedTri, sortableBranch{b, f})
		}

		// .. do so, by weight
		sort.Slice(sortedTri, func(i, j int) bool {
			return sortedTri[i].weight > sortedTri[j].weight
		})

		//
		hd.buf.WriteString(fmt.Sprintf("            // %s\n", k))
		hd.buf.WriteString(fmt.Sprintf("            case 0x00%02x%02x%02x:\n", k[2], k[1], k[0]))
		hd.buf.WriteString("            {\n")

		// only one branch? just return the letter
		if newBranches == 1 {

			for _, st := range sortedTri {
				hd.buf.WriteString(fmt.Sprintf("                return '%s';\n", quoteCharacter(st.letter)))
			}

		} else {
			// multiple branches; plug out the list of characters and weights, then call the decision fn

			hd.buf.WriteString(fmt.Sprintf("                MKV_DATA char  data_chars[%d]   = \"", newBranches+1))
			for _, st := range sortedTri {
				hd.buf.WriteString(quoteCharacter(st.letter))
			}
			hd.buf.WriteString("\";\n")

			hd.buf.WriteString(fmt.Sprintf("                MKV_DATA uint16_t data_weights[%d] = {\n", newBranches))
			for _, st := range sortedTri {
				fxp := uint16(Round(float64(st.weight) * 0x00010000))
				hd.buf.WriteString(fmt.Sprintf("                    0x%04x, // %f \n", fxp, st.weight))
			}
			hd.buf.WriteString("                };\n")

			hd.buf.WriteString(fmt.Sprintf("                return decision_fn( data_chars, data_weights, %d, input_weight, input_seed );\n", newBranches))
		}

		hd.buf.WriteString("            }\n")
		hd.buf.WriteString("            break;\n\n")
	}
	if lastRune != 0 {
		hd.emitSelectorCaseClose(lastRune)
	}

	hd.buf.WriteString("    }\n")
	hd.buf.WriteString("    return 0;\n")
	hd.buf.WriteString("} // SelectNextLetter()\n")
}

// ------------------------------------------------------------------------------------------------
func (hd *headergen) finish() {

	hd.buf.WriteString(fmt.Sprintf("\n} // namespace %s\n", hd.namespace))
	hd.buf.WriteString("} // namespace mk\n")

	if err := ioutil.WriteFile(hd.path, hd.buf.Bytes(), 0644); err != nil {
		panic(err)
	}
}

// ------------------------------------------------------------------------------------------------
func codegenRoots(fqd *freqdata, path string, namespace string) {

	outputfile := fmt.Sprintf("%smk-roots-%s.inl", path, namespace)

	hdr := codegenStartHeader(outputfile, namespace)
	hdr.emitRoots(fqd)
	hdr.finish()
}

// ------------------------------------------------------------------------------------------------
func codegenProcessor(fqd *freqdata, path string, namespace string) {

	outputfile := fmt.Sprintf("%smk-selector-%s.inl", path, namespace)

	hdr := codegenStartHeader(outputfile, namespace)
	hdr.emitSelector(fqd)
	hdr.finish()
}

// ------------------------------------------------------------------------------------------------
func codegenMasterInclude(path string, generated ...string) {

	outputfile := fmt.Sprintf("%smk-all.inl", path)

	buf := new(bytes.Buffer)
	buf.Grow(1024 * 2)

	buf.WriteString("// generated by markovich:tablegen\n// ishani.org 2021\n\n")

	buf.WriteString("#include \"inline/common-all-begin.inl\"\n\n")

	for _, gp := range generated {

		headerSelector := fmt.Sprintf("mk-selector-%s.inl", gp)
		headerRoots := fmt.Sprintf("mk-roots-%s.inl", gp)

		buf.WriteString(fmt.Sprintf("#include \"%s\"\n", headerSelector))
		buf.WriteString(fmt.Sprintf("#include \"%s\"\n", headerRoots))
	}

	buf.WriteString("\n#define MKV_CHOICE_LIST( _call )  ")
	for _, gp := range generated {
		buf.WriteString(fmt.Sprintf("\\\n    _call( %s )  ", gp))
	}

	buf.WriteString("\n\nnamespace mk {\n\n")

	buf.WriteString("enum class Choice {\n")
	for _, gp := range generated {
		buf.WriteString(fmt.Sprintf("    %s,\n", gp))
	}
	buf.WriteString("};\n")

	buf.WriteString("\n} // namespace mk\n\n")
	buf.WriteString("#include \"inline/common-all-end.inl\"\n")

	if err := ioutil.WriteFile(outputfile, buf.Bytes(), 0644); err != nil {
		panic(err)
	}
}
